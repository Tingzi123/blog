---
title: 'go:基本数据类型、运算符'
date: 2020-06-11 15:12:36
tags:
---
#### go特点

1、go=c+python，既有静态语言程序运行的速度以及安全和性能，又能达到动态语言（如脚本语言）的开发维护的高效率。
2、go语言的一个文件必须要归属一个包，不能单独存在
3、垃圾回收机制、内存自动回收
4、天然并发（超级重要）

*  从语言层面支持并发，实现简单
*  goroutine：轻量级线程，可实现大并发处理，高效利用多核
*  基于CPS并发模型（Communicating Sequential Processes）实现

5、管道通信机制，形成go语言特有的管道channel。通过管道channel可以实现不同的goroute之间的通信

6、函数返回多个值

7、新的创新，如切片slice，延时执行defer等

#### go运行
如有一个hello.go文件，运行它的两种方法
1、**go bulid** hello.go先编译这个文件，生成hello.exe二进制可执行文件，再直接切到该目录下输入hello.exe命令即可运行。
2、**go run** hello.go，编译运行一起执行，直接输出结果

区别：
1、先编译后再运行.exe文件，运行速度很快，go run命令需要编译+运行速度明显慢
2、编译后生成的.exe文件，可以放在没有go开发环境的机器上运行起来，因为hello.exe文件比hello.go文件大，因为编译后的.exe文件动态引入了运行所需要的很多库，所以可以跑起来，但go run命令不行，因为需要开发环境对.go文件进行编译。

### 变量
变量的几种数据类型
![var1](./var1.jpg)

在GO中，数据类型都有一个默认值（零值），基本数据类型的零值如下

* 整型：0
* 浮点型：0
* 字符串：“”空串
* bool类型：false

格式化%v表示按照变量的值输出

#### 1、整数类型
1、int，uint表示的位数与系统有关，32位系统表示4个字节，64位表示8个字节

2、rune，有符号，字节数等价int32，但表示一个Unicode码，用于处理带中文的字符串。

3、byte，无符号，与uint8等价，用来存储单个字符。
![var2](./var2.jpg)

4、golang整型默认声明为int类型

5、查看某个变量的占用字节大小和数据类型
fmt.Printf("n的数据类型是 %T n占用的字节数是 %d",n,unsafe.Sizeof(n))

6、在保证程序的正确运行下，尽量使用占用空间小的数据类型，遵守保小不保大的原则，若不知道该变量之后表示的值的大小，可以稍微选用大的。

#### 2、浮点类型
1、浮点类型有固定的范围和字段长度，不受具体操作系统的影响

2、golang浮点类型默认声明为float64

3、开发中，推荐使用float64，因为比float32更精确

#### 3、字符类型
1、Golang中没有专门的字符类型，存储单个字符（如ASCII码所表示的字符）使用byte来保存
注：

* 直接输出byte变量的值时，实际上是输出了对应字符的ASCII码值，如要输出对应字符，用格式化%c输出
* 输出int变量表示字符的UTF-8编码的码值时用格式化%d输出

2、Go的**字符串**是由单个**字节**连接起来的，与传统字符串由**字符**连接不同。

3、字符常量是用单引号‘’括起来的单个字符。例var c1 byte='a'  var c2 int='中'

4、Go的字符使用UTF-8编码，英文字母一个字节表示，汉字三个字节表示

5、Go中，字符的本质是一个整数，直接输出时是该字符对应的UTF-8编码的码值

6、可以给某个变量赋值一个数字，按格式化输出时%c会输出该数字对应的Unicode字符

7、字符类型可以进行运算，因为本质就是一个整数，都对应有Unicode码值

#### 4、布尔类型
1、Go中bool类型**只允许取值true和false**

2、bool类型占1个字节

#### 5、字符串类型
1、Go的**字符串**是由单个**字节**连接起来的，与传统字符串由**字符**连接不同。

2、字符串一旦赋值，就不能修改了，即Go中字符串是不可变的

3、字符串两种表示方式

* 双引号“”，会识别转义字符
* 反引号,以字符串的原生形式输出，包括换行和转义字符，可以防止攻击，输出源代码等效果。

4、字符串连接使用“+”号，多行连接时需要把“+”号放在上一行末尾

#### 6、基本数据类型转换
1、Go与Java/C不同，Go在不同类型的变量之间赋值时需要显示转换，即不能自动转换

2、数据转换时，被转换的是变量存储的数据（值），变量本身的数据类型不会改变
例：
```go
int i int32=100

var n int64=int64(i)

//i本身不会改变
```

3、高精度向低精度转换，低精度向高精度转换都可以，只是高精度向低精度转换时会溢出，和我们预想结果不一致，但编译器不会报错

#### 6、基本数据类型和字符串类型相互转换
##### 1）基本数据类型转string

1. fmt.Sprintf("%参数"，表达式）
```go
func Sprintf(format string,a ...interface{}) string

//Sprintf根据format参数生成格式化字符串并返回
```
参数需要和表达式的数据类型相匹配

2.使用strconv包的函数 

##### 2）string转基本数据类型

1. 使用strconv包的函数 

##### 3）注意事项
1、string转基本数据类型时，要**确保string类型能够转成有效的数据**。比如可以把”123“转成一个整数，但不能把”hello“转成一个整数，如果这样做，go不会报错，而是直接转成默认值。

#### 7、指针

1、值类型包括：基本数据类型、数组和结构体struct

2、引用类型包括：指针、切片slice、map、管道channel、interface

3、值类型和引用类型
![var3](./var3.jpg)


### 运算符
#### 1、算术运算符
1、Go中自增自减只能作为一个独立的语句使用
```go
b:=a++//错误
b:=a--//错误

var c int = 1
var d int
d=c++//错误，只能独立使用

var i int = 10
if i++ > 10{//错误，只能独立使用
}

var e int = 1
e++
var f int = e//正确
```
2、Go的自增自减只有后加加a++和后减减a--，去除了很多容易混淆的写法

#### 2、位运算符
1、原码、反码、补码
![op1](./op1.jpg)

```go
求-2^2=?

-2 => 原码 1000 0010 => 反码（符号位不变，其他位取反） 1111 1101 =>补码（反码+1） 1111 1110

2 =>为正数，原码、反码、补码一样 =>0000 0010

//计算机运算都是用补码运算
-2^2=1111 1110 ^ 0000 0010 = 1111 1100//结果是补码，需转换为原码

补码 1111 1100 =>反码（补码-1）1111 1011 =>原码（符号位不变，其他位取反）1000 0100 => 十进制 -4

则：-2^2=-4
```
2、Go中有两个移位运算符

* 右移运算符>>：低位溢出，符号位不变，并用符号位补溢出的高位
* 左移运算符<<：符号位不变，低位补0
