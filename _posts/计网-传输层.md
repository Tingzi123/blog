title: 计网-传输层
---

1、传输层与网络层的主要区别
网络层是为主机之间提供逻辑通信，
而运输层为应用进程之间提供端到端的逻辑通信。
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra1.png?raw=true)

2、 运输层的两个主要协议
(1) 用户数据报协议 UDP (User Datagram Protocol)
 UDP 传送的数据单位协议是 UDP 报文或用户数据报。 
UDP：一种无连接协议
提供无连接服务。
在传送数据之前不需要先建立连接。
传送的数据单位协议是 UDP 报文或用户数据报。
对方的运输层在收到 UDP 报文后，不需要给出任何确认。
虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。

UDP 的主要特点：
(1) UDP 是无连接的，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。
(2) UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
(3) UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。
(4) UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 
(5) UDP 支持一对一、一对多、多对一和多对多的交互通信。
(6) UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。

UDP 的首部格式 
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra3.png?raw=true)
伪首部仅仅是为了计算检验和
请注意，虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字。

(2) 传输控制协议 TCP (Transmission Control Protocol)
TCP 传送的数据单位协议是 TCP 报文段(segment)。
TCP：一种面向连接的协议
提供面向连接的服务。
传送的数据单位协议是 TCP 报文段 (segment)。
TCP 不提供广播或多播服务。
由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。

TCP 最主要的特点 
TCP 是面向连接的运输层协议。
每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 
TCP 提供可靠交付的服务。
TCP 提供全双工通信。
面向字节流
TCP 中的“流”(stream)指的是流入或流出进程的字节序列。
“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。

TCP 面向流的概念 
TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。
但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。
 ![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra4.png?raw=true)
注 意
TCP 连接是一条虚连接而不是一条真正的物理连接。
TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。
TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。
TCP 可把太长的数据块划分短一些再传送。
TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 
TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字 (socket) 或插口。
端口号拼接到 (contatenated with) IP 地址即构成了套接字。 
* socket = (IP地址 : 端口号)

每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：

TCP 连接 ::= {socket1, socket2} = {(IP1: port1)，(IP2: port2)}

3、两大类端口
(1) 服务器端使用的端口号
熟知端口，数值一般为 0~1023。
登记端口号，数值为 1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。
(2) 客户端使用的端口号
又称为短暂端口号，数值为 49152~65535，留给客户进程选择暂时使用。
当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。
常用端口号：
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra2.png?raw=true)

4、可靠传输的工作原理
停止等待协议
“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。
全双工通信的双方既是发送方也是接收方。

（1）无差错情况
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra5.png?raw=true)
（2）出现差错
在接收方 B 会出现两种情况：
B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。
M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。
在这两种情况下，B 都不会发送任何信息。

解决方法：
超时重传
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra6.png?raw=true)

确认丢失和确认迟到
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra7.png?raw=true)
在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。
分组和确认分组都必须进行编号。
超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 

自动重传请求 ARQ协议
通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。
使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。
像上述的这种可靠传输协议常称为自动重传请求 ARQ  (Automatic Repeat reQuest)。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。


连续 ARQ 协议（滑动窗口协议）
是 TCP 协议的精髓所在。
发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。
连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra8.png?raw=true)

累积确认 
接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。
优点：容易实现，即使确认丢失也不必重传。
缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。

Go-back-N（回退 N）
如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。
这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。
可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 

TCP 可靠通信的具体实现
TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。
TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。
TCP 两端的四个窗口经常处于动态变化之中。
TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。  

TCP 报文段的首部格式
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra9.png?raw=true)
01 源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。
02 序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 
03 确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。
数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。  
04 紧急 URG —— 当 URG  1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。
05 确认 ACK —— 只有当 ACK  1 时确认号字段才有效。当 ACK  0 时，确认号无效。 
06 推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。
07 复位 RST (ReSeT) —— 当 RST  1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
08 同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。
09 终止 FIN (FINish) —— 用来释放一个连接。FIN  1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。
10 窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。
检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。
11 填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。

5、TCP 可靠传输的实现
滑动窗口：
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra10.png?raw=true)
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra11.png?raw=true)

发送缓存用来暂时存放：
发送应用程序传送给发送方 TCP 准备发送的数据；
TCP 已发送出但尚未收到确认的数据。
接收缓存用来暂时存放：
按序到达的、但尚未被接收应用程序读取的数据；
不按序到达的数据。 

超时重传时间的选择
TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。
超时重传时间 RTO
RTO (Retransmission Time-Out) 应略大于上面得出的加权平均往返时间 RTTS。
RFC 2988 建议使用下式计算 RTO：
RTO = RTTS + 4 * RTTD 
RTTD 是 RTT 的偏差的加权平均值。

修正的 Karn 算法 
报文段每重传一次，就把 RTO 增大一些：
新的 RTO = a * (旧的 RTO) 

系数a的典型值是 2 。
当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。

6、TCP 的流量控制
利用可变窗口进行流量控制
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra12.png?raw=true)
TCP 为每一个连接设有一个持续计时器  (persistence timer) 。
只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。
若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。
若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。

7、TCP 的拥塞控制
拥塞：在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。

拥塞控制与流量控制的区别 
拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。
拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。
拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。

流量控制往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）。
流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 

TCP 的拥塞控制方法
TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。
TCP发送方维持一个拥塞窗口 CWND (Congestion Window)
拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。
发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。
所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：
真正的发送窗口值 = Min(公告窗口值，拥塞窗口值)

TCP拥塞控制算法
(1)慢开始 (Slow start)
用来确定网络的负载能力。
算法的思路：由小到大逐渐增大拥塞窗口数值。
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra13.png?raw=true)
慢开始门限 ssthresh（状态变量）：防止拥塞窗口cwnd 增长过大引起网络拥塞。
拥塞窗口 cwnd  控制方法：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 最大报文段 SMSS (Sender Maximum Segment Size) 的数值。
拥塞窗口cwnd每次的增加量 = min (N, SMSS)

慢开始门限 ssthresh 的用法如下：
当 cwnd < ssthresh 时，使用慢开始算法。
当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。

(2)拥塞避免算法
让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。
无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）：
ssthresh = max(cwnd/2，2)
cwnd = 1
执行慢开始算法
这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 

慢开始和拥塞避免算法的实现举例 
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra14.png?raw=true)

(3)快重传算法
采用快重传FR (Fast Retransmission) 算法可以让发送方尽早知道发生了个别报文段的丢失。发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。
快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。
快重传举例
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra15.png?raw=true)

（4）快恢复算法
当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：
01 慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；
02 新拥塞窗口 cwnd = 慢开始门限 ssthresh ；
03 开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra16.png?raw=true)

TCP拥塞控制流程图
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra17.png?raw=true)

发送窗口的上限值
发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：
发送窗口的上限值  Min [rwnd, cwnd]

8、 TCP 的运输连接管理
TCP 是面向连接的协议。
运输连接有三个阶段：
连接建立
数据传送
连接释放
运输连接的管理就是使运输连接的建立和释放都能正常地进行。

（1）TCP 的连接建立：采用三次（三报文）握手
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra18.png?raw=true)

（2）TCP 的连接释放：四次（四报文）握手。
![Image text](https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra19.png?raw=true)

